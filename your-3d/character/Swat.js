// Auto-generated by https://github.com/react-spring/gltfjsx

import * as THREE from "three"
import React, { useEffect, useRef, useState, useMemo } from "react"
import { useLoader, useFrame, useGraph, useThree } from "react-three-fiber"
import { getMouseDegrees } from "./utils"

function moveJoint(mouse, joint, degreeLimit = 40) {
  let degrees = getMouseDegrees(mouse.current.x, mouse.current.y, degreeLimit)
  joint.rotation.xD = THREE.MathUtils.lerp(joint.rotation.xD || 0, degrees.y, 0.1)
  joint.rotation.yD = THREE.MathUtils.lerp(joint.rotation.yD || 0, degrees.x, 0.1)
  joint.rotation.x = THREE.Math.degToRad(joint.rotation.xD)
  joint.rotation.y = THREE.Math.degToRad(joint.rotation.yD)
}

export function Swat ({ onReady = () => {}, envMap, bus, mouse, ...props }) {
  const SkeletonUtils = require('three/examples/jsm/utils/SkeletonUtils.js').SkeletonUtils
  const GLTFLoader = require('three/examples/jsm/loaders/GLTFLoader').GLTFLoader
  const FBXLoader = require('three/examples/jsm/loaders/FBXLoader').FBXLoader
  let { scene } = useLoader(GLTFLoader, "/model/swat.glb")
  let clonedScene = useMemo(() => {
    return SkeletonUtils.clone(scene)
  }, [scene])


  const group = useRef()
  const idle = useRef()
  const actions = useRef()
  const temp = useRef()
  const mixer = useRef()
  const { nodes } = useGraph(clonedScene)

  const mma = useLoader(FBXLoader, "/actions/idle-mma.fbx")
  // const happy = useLoader(FBXLoader, "/actions/idle-happy.fbx")
  // const stay = useLoader(FBXLoader, "/actions/idle-stand.fbx")

  const tauntTime = useLoader(FBXLoader, '/actions/taunt-time.fbx')
  const tauntButt = useLoader(FBXLoader, '/actions/taunt-butt.fbx')
  const tauntFight = useLoader(FBXLoader, '/actions/taunt-fight.fbx')

  const kickLeft = useLoader(FBXLoader, '/actions/mma-kick-left.fbx')
  const kickRight = useLoader(FBXLoader, '/actions/mma-kick-right.fbx')
  const kickSide = useLoader(FBXLoader, '/actions/mma-kick-side.fbx')
  const kickLow = useLoader(FBXLoader, '/actions/mma-kick-low.fbx')
  // const kickFront = useLoader(FBXLoader, '/actions/mma-kick-front.fbx')

  const kickFace = useLoader(FBXLoader, '/actions/mma-kick-face.fbx')

  useEffect(() => {
    mixer.current = new THREE.AnimationMixer()
  })

  useFrame((state, delta) => {
    if (mixer.current) {
      mixer.current.update(delta)
    }
  })

  // let getRanodmIDX = () => {
  //   let moves = Object.keys(actions.current)
  //   return Math.floor(moves.length * Math.random())
  // }

  useEffect(() => {
    idle.current = {
      // happy: mixer.current.clipAction(happy.animations[0], group.current),
      // stay: mixer.current.clipAction(stay.animations[0], group.current),
      mma: mixer.current.clipAction(mma.animations[0], group.current),
    }
    actions.current = {
      tauntFight: mixer.current.clipAction(tauntFight.animations[0], group.current),
      tauntTime: mixer.current.clipAction(tauntTime.animations[0], group.current),
      tauntButt: mixer.current.clipAction(tauntButt.animations[0], group.current),

      kickLeft: mixer.current.clipAction(kickLeft.animations[0], group.current),
      kickRight: mixer.current.clipAction(kickRight.animations[0], group.current),

      kickLow: mixer.current.clipAction(kickLow.animations[0], group.current),
      // kickFront: mixer.current.clipAction(kickFront.animations[0], group.current),
      kickFace: mixer.current.clipAction(kickFace.animations[0], group.current),
      kickSide: mixer.current.clipAction(kickSide.animations[0], group.current),
    }
    idle.current.mma.play()
    temp.current = {
      inc: 0,
      offset: 0,
      action: 0
    }

    return () => {
      if (actions.current && mixer.current) {
        try {
          mixer.current.uncacheRoot(group.current)
        } catch (e) {
        }
      }
    }
  })

  useFrame(() => {
    moveJoint(mouse, nodes.mixamorigNeck)
    moveJoint(mouse, nodes.mixamorigSpine, 25)
    let position = new THREE.Vector3()
    position.setFromMatrixPosition(nodes['mixamorigHead'].matrixWorld)
    bus.emit('swat-head', { position })
  })

  let timer = (name) => actions.current[name].getClip().duration
  let lastAction = useRef()
  let play = (name) => {
    if (!actions.current) {
      return
    }
    clearTimeout(temp.current.action)

    let idleStay = idle.current.mma
    let actionMove = actions.current[name]
    if (lastAction.current) {
      lastAction.current.fadeOut(0.5)
    }
    lastAction.current = actionMove
    // mixer.current.stopAllAction()

    idleStay.fadeOut(0.1)
    actionMove.fadeIn(0.1)

    idleStay.play()
    actionMove.reset()
    actionMove.repetitions = 1
    actionMove.play()
    temp.current.action = setTimeout(() => {
      actionMove.fadeOut(0.1)

      idleStay.reset()
      idleStay.fadeIn(0.1)
      idleStay.repetitions = Infinity
      idleStay.play()
    }, (timer(name) - 0.1 - 0.1) * 1000);
  }


  let playRandom = () => {
    let moves = Object.keys(actions.current)
    let randomMove = moves[(temp.current.offset + temp.current.inc) % (moves.length)]
    temp.current.inc++
    play(randomMove)
  }

  // useEffect(() => {
  //   actions.current.idle.play()
  //   setTimeout(() => {
  //     play('taunt')
  //   }, Math.random() * 3 * 1000)
  // })

  useEffect(() => {
    onReady({ nodes })
  })

  return (
    <group {...props}>
      <group ref={group} dispose={null}>
        <group scale={[1, 1, 1]}>
          <primitive dispose={null}  object={nodes["mixamorigHips"]} />

          {/* <primitive castShadow object={nodes["Mesh"]} /> */}
          {/* <primitive castShadow object={nodes["Mesh"]} /> */}

          <skinnedMesh dispose={null} frustumCulled={false} castShadow geometry={nodes["Mesh_1"].geometry} skeleton={nodes["Mesh_1"].skeleton}>
            <meshStandardMaterial
            envMap={envMap}
            envMapIntensity={0.5}
            metalness={nodes["Mesh_1"].material.metalness}
            roughness={nodes["Mesh_1"].material.roughness}
            map={nodes["Mesh_1"].material.map}
            normalMap={nodes["Mesh_1"].material.normalMap}
            metalnessMap={nodes["Mesh_1"].material.metalnessMap}
            alphaMap={nodes["Mesh_1"].material.alphaMap}
            roughnessMap={nodes["Mesh_1"].material.roughnessMap}
            skinning />
          </skinnedMesh>

          <skinnedMesh dispose={null} frustumCulled={false} castShadow geometry={nodes["Mesh"].geometry} skeleton={nodes["Mesh"].skeleton}>
            <meshStandardMaterial
            envMap={envMap}
            envMapIntensity={0.5}
            metalness={nodes["Mesh"].material.metalness}
            roughness={nodes["Mesh"].material.roughness}
            map={nodes["Mesh"].material.map}
            normalMap={nodes["Mesh"].material.normalMap}
            metalnessMap={nodes["Mesh"].material.metalnessMap}
            alphaMap={nodes["Mesh"].material.alphaMap}
            roughnessMap={nodes["Mesh"].material.roughnessMap}
            skinning />
          </skinnedMesh>

          <mesh position-x={0} position-y={100} position-z={0} onPointerOver={() => { console.log('pointer') }} onPointerDown={() => { playRandom() }}>
            <boxBufferGeometry args={[70, 200, 70]}></boxBufferGeometry>

            <shaderMaterial fragmentShader={`
              void main (void) {
                discard;
              }
            `}></shaderMaterial>
          </mesh>

          {/* <skinnedMesh dispose={null}  material={nodes['Mesh_1'].material} castShadow geometry={nodes["Mesh_1"].geometry} skeleton={nodes["Mesh_1"].skeleton}>
            <meshStandardMaterial map={nodes["Mesh_1"].material.map}
            normalMap={nodes["Mesh_1"].material.normalMap}
            metalnessMap={nodes["Mesh"].material.metalnessMap}
            skinning />
          </skinnedMesh> */}

        </group>
      </group>



    </group>
  )
}